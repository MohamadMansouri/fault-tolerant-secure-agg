from collections import defaultdict
from math import ceil, log2

from ftsa.protocols.buildingblocks.utils import subs_vectors, add_vectors
from ftsa.protocols.buildingblocks.PRG import PRG
from ftsa.protocols.buildingblocks.ShamirSS import SSS
from ftsa.protocols.buildingblocks.KeyAggreement import KAS



class Server(object):
    """
    A server for the FTSA scheme proposed by Google team in CCS17

    ## **Attributes**:
    -------------        
    *step* : `int` --
        The FL step (round).

    *U1* : `list` --
        Set of round 1 users' identifiers

    *U2* : `list` --
        Set of round 2 users' identifiers

    *U3* : `list` --
        Set of round 3 users' identifiers

    *U5* : `list` --
        Set of round 4 users' identifiers

    *allY* : `list` --
        The list of all user's protected inputs

    *alldhpks* : `dict` -- 
        The public key of each user
    """

    dimension = 1000 # dimension of the input
    """nb. of elements of the input vector (default: 1000)"""
    valuesize = 16 #-bit input values
    """bit length of each element in the input vector (default: 16)"""
    nclients = 10 # number of FL clients
    """number of FL clients (default: 10)"""
    expandedvaluesize = valuesize + ceil(log2(nclients))
    """The expanded bit length to hold the sum of inputs"""
    keysize = 256 # size of a DH key 
    """size of a DH key (default: 256)"""
    threshold = ceil(2*nclients / 3) # threshold for secret sharing
    """threshold for secret sharing scheme (default: 2/3 of the nb. of clients)"""

    # init the building blocks
    prg = PRG(dimension, valuesize)
    """the pseudo-random generator"""
    SSb = SSS(PRG.security) # t-out-of-n SS for the blinding mask b
    """the secret sharing scheme for sharing the blinding mask"""
    SSsk = SSS(keysize) # t-out-of-n SS for the deffie-hellman secret key
    """the secret sharing scheme for sharing the user mask"""

    def __init__(self) -> None:
        super().__init__()
        self.step = 1 # the Fl step.
        self.U1 = [] # set of round 1 users
        self.U2 = [] # set of round 2 users
        self.U3 = [] # set of round 3 users
        self.U5 = [] # set of round 4 users
        self.alldhpks = {} # received DH public keys 
        self.allY = {} # all masked inputs

    @staticmethod
    def set_scenario(dimension, valuesize, keysize, threshold, nclients):
        """Sets up the parameters of the protocol."""
        Server.dimension = dimension
        Server.valuesize = valuesize
        Server.nclients = nclients
        Server.expandedvaluesize = valuesize + ceil(log2(nclients))
        Server.keysize = keysize
        Server.threshold = threshold
        Server.prg = PRG(dimension, valuesize)
        Server.SSb = SSS(PRG.security)
        Server.SSsk = SSS(keysize)

    def new_fl_step(self):
        """Starts a new FL round. 
        
        It increments the round counter and reinitialize the state."""
        self.step += 1
        self.U1 = []
        self.U2 = []
        self.U3 = []
        self.U5 = []
        self.allY = {} 
    
    def advertise_keys(self, alldhpks, alldhpkc):
        """Round 0 - AdvertiseKeys: Server forwards advertised keys. 
        
        ** Args **:
        -----------
        *alldhpkc* : `dict` -- 
            The public key of each user (used to construct secret channels).

        *alldhpks* : `dict` -- 
            The public key of each user (used to compute the user mask).

        **Returns**: 
        ----------------
        The same public keys (type: `dict`)
        """
        self.U1 = list(alldhpkc.keys())

        assert alldhpkc.keys() == alldhpks.keys()
        assert len(self.U1) >= Server.threshold

        self.alldhpks = alldhpks

        # send for all user public keys
        return alldhpks, alldhpkc

    def share_keys(self, allekshares):
        """Round 1 - ShareKeys:  Sever forwards the shares. 
        
        ** Args **:
        -----------
        *allekshares* : `dict`
            The list of encrypted share generated by each user

        **Returns**: 
        ----------------
        A list of encrypted shares destined to each user (type: `dict`)
        """
        self.U2 = list(allekshares.keys())

        assert len(self.U2) >= Server.threshold


        # prepare eshares for each corresponding user
        ekshares = defaultdict(dict)
        for user in allekshares:
            for vuser in allekshares[user]:
                ekshares[vuser][user] = allekshares[user][vuser]
        
        # send the encrypted key shares for each corresponding user
        return ekshares

    def masked_input_collection(self, allY):
        """Round 2 - MaskedInputCollection: Sever collects the protected inputs. 
        
        ** Args **:
        -----------
        *allY* : `dict`
            The protected inputs of each user


        **Returns**: 
        ----------------
        The list of still alive users
        """
        self.U3 = list(allY.keys())
        
        assert len(self.U3) >= Server.threshold
        assert set(self.U3).issubset(set(self.U2))

        self.allY = allY

        # assert len(allebshares) >= Server.threshold

        # # prepare eshares for each corresponding user
        # ebshares = defaultdict(dict)
        # for user in allebshares:
        #     self.Ualive.append(user)
        #     for vuser in allebshares[user]:
        #         ebshares[vuser][user] = allebshares[user][vuser]

        # # aggregate all encrypted messages
        # Ytelda = Server.JL.aggregate_vector(list(allY.values()))
        # self.Ytelda = Ytelda
        # # self.Ytelda = [powmod(x.ciphertext, factorial(Server.nclients), Server.publicparam.nsquare) for x in Ytelda]

        # send the encrypted b shares for each corresponding user
        return self.U3 

    def unmasking(self, allkshares, allbshares):
        """Round 4 - UnMasking: Sever construct the blinding masks for alive users and the DH secret key for dead ones and aggregates the users' inputs. 
        
        ** Args **:
        -----------
        *allbshares* : `dict`
            The list of mask shares of all alive users per user

        *allkshares* : `dict`
            A list of shares of the DH secret key per user

        **Returns**: 
        ----------------
        The sum of the alive users' inputs (type: `list`)
        """
        self.U5 = list(allbshares.keys())

        assert len(self.U5) >= Server.threshold


        # reconstruct the blinding mask seed b for each alive user 
        bshares = defaultdict(list)
        for user in allbshares:
            for vuser in allbshares[user]:
                bshares[vuser].append(allbshares[user][vuser])
        lagcoef = []
        b = {}
        B = defaultdict(list)
        for vuser in bshares:
            assert len(bshares[vuser]) >= Server.threshold
            if not lagcoef:
                lagcoef = Server.SSb.lagrange(bshares[vuser])
            b[vuser] = Server.SSb.recon(bshares[vuser],lagcoef)
            # recompute the blinding vector B
            B[vuser] = Server.prg.eval(b[vuser])


        # reconstruct the dh key for each dead user 
        kshares = defaultdict(list)
        for user in allkshares:
            for vuser in allkshares[user]:
                kshares[vuser].append(allkshares[user][vuser])
        dhkey = {}
        lagcoef = []
        for vuser in kshares:
            assert len(kshares[vuser]) >= Server.threshold
            if not lagcoef:
                lagcoef = Server.SSsk.lagrange(kshares[vuser])
            k = Server.SSsk.recon(kshares[vuser],lagcoef)
            k = int(k)
            dhkey[vuser] = KAS().generate_from_bytes(k.to_bytes(Server.keysize // 8, "big"))

        # recompute their masking agreed keys 
        skey = {}
        for user in self.U2:
            if user in self.U3:
                continue
            key = [0] * Server.dimension
            for vuser in self.alldhpks:
                if vuser == user:
                    continue
                sv = dhkey[user].agree(self.alldhpks[vuser])
                if vuser > user:
                    key = subs_vectors(key, Server.prg.eval(sv), 2**Server.expandedvaluesize)
                else:
                    key = add_vectors(key, Server.prg.eval(sv), 2**Server.expandedvaluesize)
            
            skey[user] = key

        # decrypt the masks
        result = [0] * Server.dimension
        for user in self.allY:
            result = add_vectors(result, self.allY[user], 2**Server.expandedvaluesize) 
        for user in skey:
            result = add_vectors(result, skey[user], 2**Server.expandedvaluesize) 
        for user in B:
            result = subs_vectors(result, B[user], 2**Server.expandedvaluesize) 
        
        return result
