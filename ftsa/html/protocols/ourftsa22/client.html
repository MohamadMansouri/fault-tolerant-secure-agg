<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>protocols.ourftsa22.client API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>protocols.ourftsa22.client</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import random
from math import ceil
import gmpy2

from ftsa.protocols.buildingblocks.utils import add_vectors
from ftsa.protocols.buildingblocks.PRG import PRG
from ftsa.protocols.buildingblocks.ShamirSS import SSS, Share
from ftsa.protocols.buildingblocks.IntegerSS import IShare
from ftsa.protocols.buildingblocks.JoyeLibert import TJLS, UserKey
from ftsa.protocols.buildingblocks.VectorEncoding import VES
from ftsa.protocols.buildingblocks.KeyAggreement import KAS
from ftsa.protocols.buildingblocks.AESGCM128 import EncryptionKey as AESKEY



class Client(object):
    dimension = 1000 # dimension of the input
    valuesize = 16 #-bit input values
    nclients = 10 # number of FL clients
    keysize = 2048 # size of a JL key 
    threshold = ceil(2*nclients / 3) # threshold for secret sharing
    Uall = [i+1 for i in range(nclients)] # set of all user identifiers

    # init the building blocks
    VE = VES(keysize // 2, nclients, valuesize, dimension)
    TJL = TJLS(nclients, threshold, VE)
    pp, _ , _ = TJL.Setup(keysize) # public parameters for TJL
    prg = PRG(dimension, valuesize)
    SS = SSS(PRG.security)

    def __init__(self, user) -&gt; None:
        super().__init__()
        self.user = user # the user identifier (we use values in [1,nclients])
        self.step = 0 # the Fl step.
        self.key = gmpy2.mpz(0) # the user encryption key for JL
        self.ckeys = {} # a channel encryption key for each communication channel with each other user {v : key}
        self.U = [] # set of registered user identifiers
        self.Ualive = [] # set of alive users&#39; identifiers 
        self.bshares = {} # a share of the b value of each other user {v : bshare}
        self.keyshares = {} # a share of the key of each other user {v : keyshare}
        self.X = [] # the user input vector
        self.KAs= KAS() # DH KA scheme for computing JL key
        self.KAc= KAS() # DH KA scheme for computing channel key

    @staticmethod
    def set_scenario(dimension, valuesize, keysize, threshold, nclients, publicparam):
        Client.dimension = dimension
        Client.valuesize = valuesize
        Client.nclients = nclients
        Client.keysize = keysize
        Client.threshold = threshold
        Client.Uall = [i+1 for i in range(nclients)]
        Client.VE = VES(keysize // 2, nclients, valuesize, dimension)
        Client.TJL = TJLS(nclients,threshold, Client.VE)
        Client.TJL.Setup(keysize) 
        Client.pp = publicparam
        Client.prg = PRG(dimension, valuesize)
        Client.SS = SSS(PRG.security)

    def new_fl_step(self):
        self.step += 1
        self.Ualive = []
        self.bshares = {}
        # generate a new input vector
        self.X = [random.SystemRandom().getrandbits(Client.valuesize) for _ in range(Client.dimension)]
                
    def setup_register(self):
        # generate DH key pairs for JL key
        self.KAs.generate()
                
        # generate DH key pairs for channel key
        self.KAc.generate()

        self.U.append(self.user)

        # send user id and public keys
        return self.user, self.KAs.pk, self.KAc.pk

    def setup_keysetup(self, alldhpks, alldhpkc):
        
        assert alldhpkc.keys() == alldhpks.keys()
        assert len(alldhpkc.keys()) &gt;= self.threshold
        assert setlen(alldhpkc.values()) == len(alldhpkc.values())  
        assert setlen(alldhpks.values()) == len(alldhpks.values())  

        # for each user compute agreed key
        for vuser in alldhpkc:
            if vuser == self.user:
                continue
            
            self.U.append(vuser)

            # compute channel key
            self.ckeys[vuser] = self.KAc.agree(alldhpkc[vuser])
            
            # compute JL key
            sv = self.KAs.agree(alldhpks[vuser], Client.keysize)
            if vuser &gt; self.user:
                self.key -= sv
            else:
                self.key += sv

        self.key = UserKey(Client.pp, self.key)

        # generate t-out-of-n shares of JL key
        shares = Client.TJL.SKShare(self.key, self.threshold, self.U)
        
        # encrypt the shares for each user
        E = {}
        for share in shares:
            vuser = share.idx
            if self.user == vuser:
                self.keyshares[self.user] = share
                continue
            key = AESKEY(self.ckeys[vuser])
            message = self.user.to_bytes(2,&#34;big&#34;) + vuser.to_bytes(2,&#34;big&#34;) + gmpy2.to_binary(share.value)
            e = key.encrypt(message)
            E[vuser] = e
        
        # send the user id and the encrypted shares
        return self.user, E

    def setup_keysetup2(self, eshares):

        assert len(eshares) + 1 &gt;= self.threshold
    
        # set the registered users and decrypt the shares
        for vuser in eshares: 
            key = AESKEY(self.ckeys[vuser])
            message = key.decrypt(eshares[vuser])
            u = int.from_bytes(message[:2],&#34;big&#34;)
            v = int.from_bytes(message[2:4],&#34;big&#34;)
            assert v == self.user and u == vuser, &#34;invalid encrypted message&#34; 
            share = gmpy2.from_binary(message[4:])
            self.keyshares[vuser] = IShare(self.user, share)
        return 

    def online_encrypt(self):
        # sample a random element b
        b = random.SystemRandom().getrandbits(PRG.security)

        # extend b using PRG
        B = Client.prg.eval(b)

        # encrypt the message
        XplusB = add_vectors(self.X,B,2**(Client.VE.elementsize))
        Y = Client.TJL.Protect(Client.pp, self.key, self.step, XplusB)

        # generate t-out-of-U shares of b
        shares = Client.SS.share(self.threshold, self.nclients, b)

        # encrypt the shares for each user
        E = {}

        for share in shares:
            vuser = share.idx
            if self.user == vuser:
                self.bshares[self.user] = share
                continue
            key = AESKEY(self.ckeys[vuser])
            message = self.user.to_bytes(2,&#34;big&#34;) + vuser.to_bytes(2,&#34;big&#34;) + gmpy2.to_binary(share.value._value)
            e = key.encrypt(message)
            E[vuser] = e

        # send user id, encrypted shares, and the encrypted input
        return self.user, E, Y

    def online_construct(self, eshares):
        assert len(eshares) + 1 &gt;= self.threshold

        self.Ualive = [self.user]
        # deduce the alive users and decrypt the shares
        for vuser in eshares: 
            self.Ualive.append(vuser)
            key = AESKEY(self.ckeys[vuser])
            message = key.decrypt(eshares[vuser])
            u = int.from_bytes(message[:2],&#34;big&#34;)
            v = int.from_bytes(message[2:4],&#34;big&#34;)
            share = gmpy2.from_binary(message[4:])
            assert v == self.user and u == vuser, &#34;invalid encrypted message&#34;
            self.bshares[vuser] = Share(self.user, Client.SS.Field(share))


        # compute the shares of the missing component Ybar
        dropshares = []
        Yzeroshare = None
        if self.U != self.Ualive:
            for vuser in self.U:
                if vuser in self.Ualive:
                    continue
                dropshares.append(self.keyshares[vuser])
            if dropshares:
                Yzeroshare = Client.TJL.ShareProtect(Client.pp, dropshares, self.step)

        # send the secret shares and the missing component
        return self.user, self.bshares, Yzeroshare


def setlen(l):
    s = set()
    for e in l:
        k = repr(e)
        s.add(k)
    return len(s)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="protocols.ourftsa22.client.setlen"><code class="name flex">
<span>def <span class="ident">setlen</span></span>(<span>l)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setlen(l):
    s = set()
    for e in l:
        k = repr(e)
        s.add(k)
    return len(s)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="protocols.ourftsa22.client.Client"><code class="flex name class">
<span>class <span class="ident">Client</span></span>
<span>(</span><span>user)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Client(object):
    dimension = 1000 # dimension of the input
    valuesize = 16 #-bit input values
    nclients = 10 # number of FL clients
    keysize = 2048 # size of a JL key 
    threshold = ceil(2*nclients / 3) # threshold for secret sharing
    Uall = [i+1 for i in range(nclients)] # set of all user identifiers

    # init the building blocks
    VE = VES(keysize // 2, nclients, valuesize, dimension)
    TJL = TJLS(nclients, threshold, VE)
    pp, _ , _ = TJL.Setup(keysize) # public parameters for TJL
    prg = PRG(dimension, valuesize)
    SS = SSS(PRG.security)

    def __init__(self, user) -&gt; None:
        super().__init__()
        self.user = user # the user identifier (we use values in [1,nclients])
        self.step = 0 # the Fl step.
        self.key = gmpy2.mpz(0) # the user encryption key for JL
        self.ckeys = {} # a channel encryption key for each communication channel with each other user {v : key}
        self.U = [] # set of registered user identifiers
        self.Ualive = [] # set of alive users&#39; identifiers 
        self.bshares = {} # a share of the b value of each other user {v : bshare}
        self.keyshares = {} # a share of the key of each other user {v : keyshare}
        self.X = [] # the user input vector
        self.KAs= KAS() # DH KA scheme for computing JL key
        self.KAc= KAS() # DH KA scheme for computing channel key

    @staticmethod
    def set_scenario(dimension, valuesize, keysize, threshold, nclients, publicparam):
        Client.dimension = dimension
        Client.valuesize = valuesize
        Client.nclients = nclients
        Client.keysize = keysize
        Client.threshold = threshold
        Client.Uall = [i+1 for i in range(nclients)]
        Client.VE = VES(keysize // 2, nclients, valuesize, dimension)
        Client.TJL = TJLS(nclients,threshold, Client.VE)
        Client.TJL.Setup(keysize) 
        Client.pp = publicparam
        Client.prg = PRG(dimension, valuesize)
        Client.SS = SSS(PRG.security)

    def new_fl_step(self):
        self.step += 1
        self.Ualive = []
        self.bshares = {}
        # generate a new input vector
        self.X = [random.SystemRandom().getrandbits(Client.valuesize) for _ in range(Client.dimension)]
                
    def setup_register(self):
        # generate DH key pairs for JL key
        self.KAs.generate()
                
        # generate DH key pairs for channel key
        self.KAc.generate()

        self.U.append(self.user)

        # send user id and public keys
        return self.user, self.KAs.pk, self.KAc.pk

    def setup_keysetup(self, alldhpks, alldhpkc):
        
        assert alldhpkc.keys() == alldhpks.keys()
        assert len(alldhpkc.keys()) &gt;= self.threshold
        assert setlen(alldhpkc.values()) == len(alldhpkc.values())  
        assert setlen(alldhpks.values()) == len(alldhpks.values())  

        # for each user compute agreed key
        for vuser in alldhpkc:
            if vuser == self.user:
                continue
            
            self.U.append(vuser)

            # compute channel key
            self.ckeys[vuser] = self.KAc.agree(alldhpkc[vuser])
            
            # compute JL key
            sv = self.KAs.agree(alldhpks[vuser], Client.keysize)
            if vuser &gt; self.user:
                self.key -= sv
            else:
                self.key += sv

        self.key = UserKey(Client.pp, self.key)

        # generate t-out-of-n shares of JL key
        shares = Client.TJL.SKShare(self.key, self.threshold, self.U)
        
        # encrypt the shares for each user
        E = {}
        for share in shares:
            vuser = share.idx
            if self.user == vuser:
                self.keyshares[self.user] = share
                continue
            key = AESKEY(self.ckeys[vuser])
            message = self.user.to_bytes(2,&#34;big&#34;) + vuser.to_bytes(2,&#34;big&#34;) + gmpy2.to_binary(share.value)
            e = key.encrypt(message)
            E[vuser] = e
        
        # send the user id and the encrypted shares
        return self.user, E

    def setup_keysetup2(self, eshares):

        assert len(eshares) + 1 &gt;= self.threshold
    
        # set the registered users and decrypt the shares
        for vuser in eshares: 
            key = AESKEY(self.ckeys[vuser])
            message = key.decrypt(eshares[vuser])
            u = int.from_bytes(message[:2],&#34;big&#34;)
            v = int.from_bytes(message[2:4],&#34;big&#34;)
            assert v == self.user and u == vuser, &#34;invalid encrypted message&#34; 
            share = gmpy2.from_binary(message[4:])
            self.keyshares[vuser] = IShare(self.user, share)
        return 

    def online_encrypt(self):
        # sample a random element b
        b = random.SystemRandom().getrandbits(PRG.security)

        # extend b using PRG
        B = Client.prg.eval(b)

        # encrypt the message
        XplusB = add_vectors(self.X,B,2**(Client.VE.elementsize))
        Y = Client.TJL.Protect(Client.pp, self.key, self.step, XplusB)

        # generate t-out-of-U shares of b
        shares = Client.SS.share(self.threshold, self.nclients, b)

        # encrypt the shares for each user
        E = {}

        for share in shares:
            vuser = share.idx
            if self.user == vuser:
                self.bshares[self.user] = share
                continue
            key = AESKEY(self.ckeys[vuser])
            message = self.user.to_bytes(2,&#34;big&#34;) + vuser.to_bytes(2,&#34;big&#34;) + gmpy2.to_binary(share.value._value)
            e = key.encrypt(message)
            E[vuser] = e

        # send user id, encrypted shares, and the encrypted input
        return self.user, E, Y

    def online_construct(self, eshares):
        assert len(eshares) + 1 &gt;= self.threshold

        self.Ualive = [self.user]
        # deduce the alive users and decrypt the shares
        for vuser in eshares: 
            self.Ualive.append(vuser)
            key = AESKEY(self.ckeys[vuser])
            message = key.decrypt(eshares[vuser])
            u = int.from_bytes(message[:2],&#34;big&#34;)
            v = int.from_bytes(message[2:4],&#34;big&#34;)
            share = gmpy2.from_binary(message[4:])
            assert v == self.user and u == vuser, &#34;invalid encrypted message&#34;
            self.bshares[vuser] = Share(self.user, Client.SS.Field(share))


        # compute the shares of the missing component Ybar
        dropshares = []
        Yzeroshare = None
        if self.U != self.Ualive:
            for vuser in self.U:
                if vuser in self.Ualive:
                    continue
                dropshares.append(self.keyshares[vuser])
            if dropshares:
                Yzeroshare = Client.TJL.ShareProtect(Client.pp, dropshares, self.step)

        # send the secret shares and the missing component
        return self.user, self.bshares, Yzeroshare</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="protocols.ourftsa22.client.Client.dimension"><code class="name">var <span class="ident">dimension</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="protocols.ourftsa22.client.Client.valuesize"><code class="name">var <span class="ident">valuesize</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="protocols.ourftsa22.client.Client.nclients"><code class="name">var <span class="ident">nclients</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="protocols.ourftsa22.client.Client.keysize"><code class="name">var <span class="ident">keysize</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="protocols.ourftsa22.client.Client.threshold"><code class="name">var <span class="ident">threshold</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="protocols.ourftsa22.client.Client.Uall"><code class="name">var <span class="ident">Uall</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="protocols.ourftsa22.client.Client.VE"><code class="name">var <span class="ident">VE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="protocols.ourftsa22.client.Client.TJL"><code class="name">var <span class="ident">TJL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="protocols.ourftsa22.client.Client.pp"><code class="name">var <span class="ident">pp</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="protocols.ourftsa22.client.Client.prg"><code class="name">var <span class="ident">prg</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="protocols.ourftsa22.client.Client.SS"><code class="name">var <span class="ident">SS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="protocols.ourftsa22.client.Client.set_scenario"><code class="name flex">
<span>def <span class="ident">set_scenario</span></span>(<span>dimension, valuesize, keysize, threshold, nclients, publicparam)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def set_scenario(dimension, valuesize, keysize, threshold, nclients, publicparam):
    Client.dimension = dimension
    Client.valuesize = valuesize
    Client.nclients = nclients
    Client.keysize = keysize
    Client.threshold = threshold
    Client.Uall = [i+1 for i in range(nclients)]
    Client.VE = VES(keysize // 2, nclients, valuesize, dimension)
    Client.TJL = TJLS(nclients,threshold, Client.VE)
    Client.TJL.Setup(keysize) 
    Client.pp = publicparam
    Client.prg = PRG(dimension, valuesize)
    Client.SS = SSS(PRG.security)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="protocols.ourftsa22.client.Client.new_fl_step"><code class="name flex">
<span>def <span class="ident">new_fl_step</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_fl_step(self):
    self.step += 1
    self.Ualive = []
    self.bshares = {}
    # generate a new input vector
    self.X = [random.SystemRandom().getrandbits(Client.valuesize) for _ in range(Client.dimension)]</code></pre>
</details>
</dd>
<dt id="protocols.ourftsa22.client.Client.setup_register"><code class="name flex">
<span>def <span class="ident">setup_register</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_register(self):
    # generate DH key pairs for JL key
    self.KAs.generate()
            
    # generate DH key pairs for channel key
    self.KAc.generate()

    self.U.append(self.user)

    # send user id and public keys
    return self.user, self.KAs.pk, self.KAc.pk</code></pre>
</details>
</dd>
<dt id="protocols.ourftsa22.client.Client.setup_keysetup"><code class="name flex">
<span>def <span class="ident">setup_keysetup</span></span>(<span>self, alldhpks, alldhpkc)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_keysetup(self, alldhpks, alldhpkc):
    
    assert alldhpkc.keys() == alldhpks.keys()
    assert len(alldhpkc.keys()) &gt;= self.threshold
    assert setlen(alldhpkc.values()) == len(alldhpkc.values())  
    assert setlen(alldhpks.values()) == len(alldhpks.values())  

    # for each user compute agreed key
    for vuser in alldhpkc:
        if vuser == self.user:
            continue
        
        self.U.append(vuser)

        # compute channel key
        self.ckeys[vuser] = self.KAc.agree(alldhpkc[vuser])
        
        # compute JL key
        sv = self.KAs.agree(alldhpks[vuser], Client.keysize)
        if vuser &gt; self.user:
            self.key -= sv
        else:
            self.key += sv

    self.key = UserKey(Client.pp, self.key)

    # generate t-out-of-n shares of JL key
    shares = Client.TJL.SKShare(self.key, self.threshold, self.U)
    
    # encrypt the shares for each user
    E = {}
    for share in shares:
        vuser = share.idx
        if self.user == vuser:
            self.keyshares[self.user] = share
            continue
        key = AESKEY(self.ckeys[vuser])
        message = self.user.to_bytes(2,&#34;big&#34;) + vuser.to_bytes(2,&#34;big&#34;) + gmpy2.to_binary(share.value)
        e = key.encrypt(message)
        E[vuser] = e
    
    # send the user id and the encrypted shares
    return self.user, E</code></pre>
</details>
</dd>
<dt id="protocols.ourftsa22.client.Client.setup_keysetup2"><code class="name flex">
<span>def <span class="ident">setup_keysetup2</span></span>(<span>self, eshares)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_keysetup2(self, eshares):

    assert len(eshares) + 1 &gt;= self.threshold

    # set the registered users and decrypt the shares
    for vuser in eshares: 
        key = AESKEY(self.ckeys[vuser])
        message = key.decrypt(eshares[vuser])
        u = int.from_bytes(message[:2],&#34;big&#34;)
        v = int.from_bytes(message[2:4],&#34;big&#34;)
        assert v == self.user and u == vuser, &#34;invalid encrypted message&#34; 
        share = gmpy2.from_binary(message[4:])
        self.keyshares[vuser] = IShare(self.user, share)
    return </code></pre>
</details>
</dd>
<dt id="protocols.ourftsa22.client.Client.online_encrypt"><code class="name flex">
<span>def <span class="ident">online_encrypt</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def online_encrypt(self):
    # sample a random element b
    b = random.SystemRandom().getrandbits(PRG.security)

    # extend b using PRG
    B = Client.prg.eval(b)

    # encrypt the message
    XplusB = add_vectors(self.X,B,2**(Client.VE.elementsize))
    Y = Client.TJL.Protect(Client.pp, self.key, self.step, XplusB)

    # generate t-out-of-U shares of b
    shares = Client.SS.share(self.threshold, self.nclients, b)

    # encrypt the shares for each user
    E = {}

    for share in shares:
        vuser = share.idx
        if self.user == vuser:
            self.bshares[self.user] = share
            continue
        key = AESKEY(self.ckeys[vuser])
        message = self.user.to_bytes(2,&#34;big&#34;) + vuser.to_bytes(2,&#34;big&#34;) + gmpy2.to_binary(share.value._value)
        e = key.encrypt(message)
        E[vuser] = e

    # send user id, encrypted shares, and the encrypted input
    return self.user, E, Y</code></pre>
</details>
</dd>
<dt id="protocols.ourftsa22.client.Client.online_construct"><code class="name flex">
<span>def <span class="ident">online_construct</span></span>(<span>self, eshares)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def online_construct(self, eshares):
    assert len(eshares) + 1 &gt;= self.threshold

    self.Ualive = [self.user]
    # deduce the alive users and decrypt the shares
    for vuser in eshares: 
        self.Ualive.append(vuser)
        key = AESKEY(self.ckeys[vuser])
        message = key.decrypt(eshares[vuser])
        u = int.from_bytes(message[:2],&#34;big&#34;)
        v = int.from_bytes(message[2:4],&#34;big&#34;)
        share = gmpy2.from_binary(message[4:])
        assert v == self.user and u == vuser, &#34;invalid encrypted message&#34;
        self.bshares[vuser] = Share(self.user, Client.SS.Field(share))


    # compute the shares of the missing component Ybar
    dropshares = []
    Yzeroshare = None
    if self.U != self.Ualive:
        for vuser in self.U:
            if vuser in self.Ualive:
                continue
            dropshares.append(self.keyshares[vuser])
        if dropshares:
            Yzeroshare = Client.TJL.ShareProtect(Client.pp, dropshares, self.step)

    # send the secret shares and the missing component
    return self.user, self.bshares, Yzeroshare</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="protocols.ourftsa22" href="index.html">protocols.ourftsa22</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="protocols.ourftsa22.client.setlen" href="#protocols.ourftsa22.client.setlen">setlen</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="protocols.ourftsa22.client.Client" href="#protocols.ourftsa22.client.Client">Client</a></code></h4>
<ul class="two-column">
<li><code><a title="protocols.ourftsa22.client.Client.set_scenario" href="#protocols.ourftsa22.client.Client.set_scenario">set_scenario</a></code></li>
<li><code><a title="protocols.ourftsa22.client.Client.new_fl_step" href="#protocols.ourftsa22.client.Client.new_fl_step">new_fl_step</a></code></li>
<li><code><a title="protocols.ourftsa22.client.Client.setup_register" href="#protocols.ourftsa22.client.Client.setup_register">setup_register</a></code></li>
<li><code><a title="protocols.ourftsa22.client.Client.setup_keysetup" href="#protocols.ourftsa22.client.Client.setup_keysetup">setup_keysetup</a></code></li>
<li><code><a title="protocols.ourftsa22.client.Client.setup_keysetup2" href="#protocols.ourftsa22.client.Client.setup_keysetup2">setup_keysetup2</a></code></li>
<li><code><a title="protocols.ourftsa22.client.Client.online_encrypt" href="#protocols.ourftsa22.client.Client.online_encrypt">online_encrypt</a></code></li>
<li><code><a title="protocols.ourftsa22.client.Client.online_construct" href="#protocols.ourftsa22.client.Client.online_construct">online_construct</a></code></li>
<li><code><a title="protocols.ourftsa22.client.Client.dimension" href="#protocols.ourftsa22.client.Client.dimension">dimension</a></code></li>
<li><code><a title="protocols.ourftsa22.client.Client.valuesize" href="#protocols.ourftsa22.client.Client.valuesize">valuesize</a></code></li>
<li><code><a title="protocols.ourftsa22.client.Client.nclients" href="#protocols.ourftsa22.client.Client.nclients">nclients</a></code></li>
<li><code><a title="protocols.ourftsa22.client.Client.keysize" href="#protocols.ourftsa22.client.Client.keysize">keysize</a></code></li>
<li><code><a title="protocols.ourftsa22.client.Client.threshold" href="#protocols.ourftsa22.client.Client.threshold">threshold</a></code></li>
<li><code><a title="protocols.ourftsa22.client.Client.Uall" href="#protocols.ourftsa22.client.Client.Uall">Uall</a></code></li>
<li><code><a title="protocols.ourftsa22.client.Client.VE" href="#protocols.ourftsa22.client.Client.VE">VE</a></code></li>
<li><code><a title="protocols.ourftsa22.client.Client.TJL" href="#protocols.ourftsa22.client.Client.TJL">TJL</a></code></li>
<li><code><a title="protocols.ourftsa22.client.Client.pp" href="#protocols.ourftsa22.client.Client.pp">pp</a></code></li>
<li><code><a title="protocols.ourftsa22.client.Client.prg" href="#protocols.ourftsa22.client.Client.prg">prg</a></code></li>
<li><code><a title="protocols.ourftsa22.client.Client.SS" href="#protocols.ourftsa22.client.Client.SS">SS</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>