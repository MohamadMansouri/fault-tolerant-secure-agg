<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ftsa.protocols.ccsftsa17.client API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ftsa.protocols.ccsftsa17.client</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import random
from math import ceil, log2
from ecdsa import keys
from ecdsa.curves import SECP112r1
import gmpy2

from ftsa.protocols.buildingblocks.utils import add_vectors, subs_vectors
from ftsa.protocols.buildingblocks.PRG import PRG
from ftsa.protocols.buildingblocks.ShamirSS import SSS, Share
from ftsa.protocols.buildingblocks.KeyAggreement import KAS
from ftsa.protocols.buildingblocks.AESGCM128 import EncryptionKey as AESKEY



class Client(object):
    &#34;&#34;&#34;
    A client for the FTSA scheme proposed by Google team in CCS17

    ## **Args**:
    -------------        
    *user* : `int` --
        The user&#39;s id

    ## **Attributes**:
    -------------        
    *user* : `int` --
        The user&#39;s id

    *step* : `int` --
        The FL step (round).

    *key* : `list` --
        The user&#39;s mask

    *ckeys* : `dict` --
        A channel encryption key for each communication channel with each other user {v : key}

    *U1* : `list` --
        Set of round 1 users&#39; identifiers

    *U2* : `list` --
        Set of round 2 users&#39; identifiers

    *U4* : `list` --
        Set of round 4 users&#39; identifiers

    *bshares* : `dict` --
        A share of the b value of each other user {v : bshare}

    *keyshares* : `dict` --
        A share of the key of each other user {v : keyshare}

    *X* : `list` --
        The user input vector

    *KAs*  : `KAS` --
        DH KA scheme for computing JL key

    *KAc*  : `KAS` --
        DH KA scheme for computing channel key

    *b* : `int` --
        The blinding mask seed
    
    *alldhpks* : `dict` -- 
        The public key of each user (used to compute the user&#39;s mask).
    &#34;&#34;&#34;

    dimension = 1000 # dimension of the input
    &#34;&#34;&#34;nb. of elements of the input vector (default: 1000)&#34;&#34;&#34;
    valuesize = 16 #-bit input values
    &#34;&#34;&#34;bit length of each element in the input vector (default: 16)&#34;&#34;&#34;
    nclients = 10 # number of FL clients
    &#34;&#34;&#34;number of FL clients (default: 10)&#34;&#34;&#34;
    expandedvaluesize = valuesize + ceil(log2(nclients))
    &#34;&#34;&#34;The expanded bit length to hold the sum of inputs&#34;&#34;&#34;
    keysize = 256 # size of a DH key 
    &#34;&#34;&#34;size of a DH key (default: 256)&#34;&#34;&#34;
    threshold = ceil(2*nclients / 3) # threshold for secret sharing
    &#34;&#34;&#34;threshold for secret sharing scheme (default: 2/3 of the nb. of clients)&#34;&#34;&#34;
    Uall = [i+1 for i in range(nclients)] # set of all user identifiers
    &#34;&#34;&#34;set of all user identifiers&#34;&#34;&#34;

    # init the building blocks
    prg = PRG(dimension, valuesize)
    &#34;&#34;&#34;the pseudo-random generator&#34;&#34;&#34;
    SSb = SSS(PRG.security) # t-out-of-n SS for the blinding mask b
    &#34;&#34;&#34;the secret sharing scheme for sharing the blinding mask&#34;&#34;&#34;
    SSsk = SSS(keysize) # t-out-of-n SS for the deffie-hellman secret key
    &#34;&#34;&#34;the secret sharing scheme for sharing the user mask&#34;&#34;&#34;


    def __init__(self, user) -&gt; None:
        super().__init__()
        self.user = user # the user identifier (we use values in [1,nclients])
        self.step = 1 # the Fl step.
        self.key = [0]*Client.dimension # the user masking key 
        self.ckeys = {} # a channel encryption key for each communication channel with each other user {v : key}
        self.U1 = [] # set of round 1 users
        self.U2 = [] # set of round 2 users
        self.U4 = [] # set of round 4 users
        self.bshares = {} # a share of the b value of each other user {v : bshare}
        self.keyshares = {} # a share of the key of each other user {v : keyshare}
        self.X = [] # the user input vector
        self.KAs= KAS() # DH KA scheme for computing masking key
        self.KAc= KAS() # DH KA scheme for computing channel key
        self.b = 0 # blinding mask
        self.alldhpks = {} # received DH public keys 

    @staticmethod
    def set_scenario(dimension, valuesize, keysize, threshold, nclients):
        &#34;&#34;&#34;Sets up the parameters of the protocol.&#34;&#34;&#34;
        Client.dimension = dimension
        Client.valuesize = valuesize
        Client.nclients = nclients
        Client.expandedvaluesize = valuesize + ceil(log2(nclients))
        Client.keysize = keysize
        Client.threshold = threshold
        Client.Uall = [i+1 for i in range(nclients)]
        Client.prg = PRG(dimension, valuesize)
        Client.SSb = SSS(PRG.security)
        Client.SSsk = SSS(keysize)

    def new_fl_step(self):
        &#34;&#34;&#34;Starts a new FL round. 
        
        It increments the round counter and regenrates a new random input (This should be replaced with the actual training of the model).&#34;&#34;&#34;   
        self.step += 1
        self.U1 = []
        self.U2 = []
        self.U4 = []
        self.bshares = {}
        self.keyshares = {}
        self.bshares = {}
        self.KAs= KAS() 
        self.KAc= KAS() 
        self.ckeys = {}
        self.b = 0
        self.alldhpks = {}
        self.key = [0]*Client.dimension
        # generate a new input vector
        self.X = [random.SystemRandom().getrandbits(Client.valuesize) for _ in range(Client.dimension)]
                
    def advertise_keys(self):
        &#34;&#34;&#34;Round 0 - AdvertiseKeys: User advertise the his generated keys. 
        
        **Returns**: 
        ----------------
        A user identifier, and two public keys (type: (`int`, `PublicKey`, `PublicKey`)).
        &#34;&#34;&#34;

        # generate DH key pairs for masking key
        self.KAs.generate()
                
        # generate DH key pairs for channel key
        self.KAc.generate()

        self.U1.append(self.user)

        # send user id and public keys
        return self.user, self.KAs.pk, self.KAc.pk

    def share_keys(self, alldhpks, alldhpkc):
        &#34;&#34;&#34;Round 1 - ShareKeys: User setups and share its keys with other users. 
        
        It accepts the public keys of other users and computes the shared keys and the JL key. It also shares the JL key using **TJL.SKShare** and returns its shares.
        
        ** Args **:
        -----------
        *alldhpkc* : `dict` -- 
            The public key of each user (used to construct secret channels).

        *alldhpks* : `dict` -- 
            The public key of each user (used to compute the user mask).

        **Returns**: 
        ----------------
        The user identifier and a dictionary of encrypted share pairs of the blinding mask and DH secret key  (type: (`int`, `dict`)).
        &#34;&#34;&#34;
        assert alldhpkc.keys() == alldhpks.keys()
        assert len(alldhpkc.keys()) &gt;= self.threshold
        assert _setlen(alldhpkc.values()) == len(alldhpkc.values())  
        assert _setlen(alldhpks.values()) == len(alldhpks.values())  

        self.U1 += list(alldhpks.keys())

        # for each user compute agreed key
        for vuser in alldhpkc:
            if vuser == self.user:
                continue
            # compute channel key
            self.ckeys[vuser] = self.KAc.agree(alldhpkc[vuser])


        # sample a random element b
        self.b = random.SystemRandom().getrandbits(128)

        # generate t-out-of-U shares of b
        bshares = Client.SSb.share(self.threshold, self.nclients, self.b)


        # generate t-out-of-n shares of DH key
        kshares = Client.SSsk.share(self.threshold, self.nclients, self.KAs.get_sk_bytes())

        # encrypt the shares for each user
        E = {}
        for kshare, bshare in zip(kshares, bshares):
            assert kshare.idx == bshare.idx
            vuser = kshare.idx
            if self.user == vuser:
                self.keyshares[self.user] = kshare
                self.bshares[self.user] = bshare
                continue
            key = AESKEY(self.ckeys[vuser])
            sharelen = len(gmpy2.to_binary(kshare.value._value))
            message = self.user.to_bytes(2,&#34;big&#34;) + vuser.to_bytes(2,&#34;big&#34;) + sharelen.to_bytes(2,&#34;big&#34;) + gmpy2.to_binary(kshare.value._value) + gmpy2.to_binary(bshare.value._value)
            e = key.encrypt(message)
            E[vuser] = e

        self.alldhpks = alldhpks
     
        # send the user id and the encrypted shares
        return self.user, E

    def masked_input_collection(self, eshares):
        &#34;&#34;&#34;Round 2 - MaskedInputCollection: User protect its input and sends it to the server. 
        
        ## **Args**:
        -------------
        *eshares* : `dict` -- 
            The encrypted shares of the blinding mask and the Dh key of the users

        **Returns**: 
        ----------------
        The user identifier, and the protected input (type: (`int`, `list`).&#34;&#34;&#34;
        assert len(eshares) + 1 &gt;= self.threshold

        self.U2 = [self.user] + list(eshares.keys())
        self.eshares = eshares

        # for each user compute masking agreed key
        for vuser in self.alldhpks:
            if vuser == self.user:
                continue
            # compute masking key
            sv = self.KAs.agree(self.alldhpks[vuser])
            if vuser &gt; self.user:
                self.key = subs_vectors(self.key, Client.prg.eval(sv), 2**Client.expandedvaluesize)
            else:
                self.key = add_vectors(self.key, Client.prg.eval(sv), 2**Client.expandedvaluesize)
        
        # extend b using PRG
        B = Client.prg.eval(self.b)

        # compute the masked input
        mask = add_vectors(self.key, B, 2**Client.expandedvaluesize)
        Y = add_vectors(self.X, mask, 2**Client.expandedvaluesize)

        return self.user, Y

    def unmasking(self, U4):
        &#34;&#34;&#34;Round 4 - UnMasking: User send the shares of the users to the server.

        ** Args **:
        -----------
        *U4* : `list` -- 
            The list of still alive users

        **Returns**: 
        ----------------
        The user identifier, the shares of the DH secret key for dead users, and the shares of the blinding mask seed of alive users (type: (`int`, `dict`, `dict`)).
        &#34;&#34;&#34;
        assert len(U4) &gt;= self.threshold
        assert set(U4).issubset(set(self.U2))

        self.U4 = U4

        # decrypt the shares
        for vuser in self.eshares: 
            key = AESKEY(self.ckeys[vuser])
            message = key.decrypt(self.eshares[vuser])
            u = int.from_bytes(message[:2],&#34;big&#34;)
            v = int.from_bytes(message[2:4],&#34;big&#34;)
            sharelen = int.from_bytes(message[4:6],&#34;big&#34;)
            assert v == self.user and u == vuser, &#34;invalid encrypted message&#34;
            kshare = gmpy2.from_binary(message[6:sharelen+6])
            bshare = gmpy2.from_binary(message[sharelen+6:])
            self.bshares[vuser] = Share(self.user, Client.SSb.Field(bshare))
            self.keyshares[vuser] = Share(self.user, Client.SSsk.Field(kshare))


        # send either the b share of the key share of each user
        bshares = {}
        kshares = {}
        for vuser in self.U2:
            if vuser in self.U4:
                bshares[vuser] = self.bshares[vuser]
            else:
                kshares[vuser] = self.keyshares[vuser]


        # send the secret shares of b and key
        return self.user, kshares, bshares




def _setlen(l):
    s = set()
    for e in l:
        k = repr(e)
        s.add(k)
    return len(s)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ftsa.protocols.ccsftsa17.client.Client"><code class="flex name class">
<span>class <span class="ident">Client</span></span>
<span>(</span><span>user)</span>
</code></dt>
<dd>
<div class="desc"><p>A client for the FTSA scheme proposed by Google team in CCS17</p>
<h2 id="args"><strong>Args</strong>:</h2>
<hr>
<p><em>user</em> : <code>int</code> &ndash;
The user's id</p>
<h2 id="attributes"><strong>Attributes</strong>:</h2>
<hr>
<p><em>user</em> : <code>int</code> &ndash;
The user's id</p>
<p><em>step</em> : <code>int</code> &ndash;
The FL step (round).</p>
<p><em>key</em> : <code>list</code> &ndash;
The user's mask</p>
<p><em>ckeys</em> : <code>dict</code> &ndash;
A channel encryption key for each communication channel with each other user {v : key}</p>
<p><em>U1</em> : <code>list</code> &ndash;
Set of round 1 users' identifiers</p>
<p><em>U2</em> : <code>list</code> &ndash;
Set of round 2 users' identifiers</p>
<p><em>U4</em> : <code>list</code> &ndash;
Set of round 4 users' identifiers</p>
<p><em>bshares</em> : <code>dict</code> &ndash;
A share of the b value of each other user {v : bshare}</p>
<p><em>keyshares</em> : <code>dict</code> &ndash;
A share of the key of each other user {v : keyshare}</p>
<p><em>X</em> : <code>list</code> &ndash;
The user input vector</p>
<p><em>KAs</em>
: <code>KAS</code> &ndash;
DH KA scheme for computing JL key</p>
<p><em>KAc</em>
: <code>KAS</code> &ndash;
DH KA scheme for computing channel key</p>
<p><em>b</em> : <code>int</code> &ndash;
The blinding mask seed</p>
<p><em>alldhpks</em> : <code>dict</code> &ndash;
The public key of each user (used to compute the user's mask).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Client(object):
    &#34;&#34;&#34;
    A client for the FTSA scheme proposed by Google team in CCS17

    ## **Args**:
    -------------        
    *user* : `int` --
        The user&#39;s id

    ## **Attributes**:
    -------------        
    *user* : `int` --
        The user&#39;s id

    *step* : `int` --
        The FL step (round).

    *key* : `list` --
        The user&#39;s mask

    *ckeys* : `dict` --
        A channel encryption key for each communication channel with each other user {v : key}

    *U1* : `list` --
        Set of round 1 users&#39; identifiers

    *U2* : `list` --
        Set of round 2 users&#39; identifiers

    *U4* : `list` --
        Set of round 4 users&#39; identifiers

    *bshares* : `dict` --
        A share of the b value of each other user {v : bshare}

    *keyshares* : `dict` --
        A share of the key of each other user {v : keyshare}

    *X* : `list` --
        The user input vector

    *KAs*  : `KAS` --
        DH KA scheme for computing JL key

    *KAc*  : `KAS` --
        DH KA scheme for computing channel key

    *b* : `int` --
        The blinding mask seed
    
    *alldhpks* : `dict` -- 
        The public key of each user (used to compute the user&#39;s mask).
    &#34;&#34;&#34;

    dimension = 1000 # dimension of the input
    &#34;&#34;&#34;nb. of elements of the input vector (default: 1000)&#34;&#34;&#34;
    valuesize = 16 #-bit input values
    &#34;&#34;&#34;bit length of each element in the input vector (default: 16)&#34;&#34;&#34;
    nclients = 10 # number of FL clients
    &#34;&#34;&#34;number of FL clients (default: 10)&#34;&#34;&#34;
    expandedvaluesize = valuesize + ceil(log2(nclients))
    &#34;&#34;&#34;The expanded bit length to hold the sum of inputs&#34;&#34;&#34;
    keysize = 256 # size of a DH key 
    &#34;&#34;&#34;size of a DH key (default: 256)&#34;&#34;&#34;
    threshold = ceil(2*nclients / 3) # threshold for secret sharing
    &#34;&#34;&#34;threshold for secret sharing scheme (default: 2/3 of the nb. of clients)&#34;&#34;&#34;
    Uall = [i+1 for i in range(nclients)] # set of all user identifiers
    &#34;&#34;&#34;set of all user identifiers&#34;&#34;&#34;

    # init the building blocks
    prg = PRG(dimension, valuesize)
    &#34;&#34;&#34;the pseudo-random generator&#34;&#34;&#34;
    SSb = SSS(PRG.security) # t-out-of-n SS for the blinding mask b
    &#34;&#34;&#34;the secret sharing scheme for sharing the blinding mask&#34;&#34;&#34;
    SSsk = SSS(keysize) # t-out-of-n SS for the deffie-hellman secret key
    &#34;&#34;&#34;the secret sharing scheme for sharing the user mask&#34;&#34;&#34;


    def __init__(self, user) -&gt; None:
        super().__init__()
        self.user = user # the user identifier (we use values in [1,nclients])
        self.step = 1 # the Fl step.
        self.key = [0]*Client.dimension # the user masking key 
        self.ckeys = {} # a channel encryption key for each communication channel with each other user {v : key}
        self.U1 = [] # set of round 1 users
        self.U2 = [] # set of round 2 users
        self.U4 = [] # set of round 4 users
        self.bshares = {} # a share of the b value of each other user {v : bshare}
        self.keyshares = {} # a share of the key of each other user {v : keyshare}
        self.X = [] # the user input vector
        self.KAs= KAS() # DH KA scheme for computing masking key
        self.KAc= KAS() # DH KA scheme for computing channel key
        self.b = 0 # blinding mask
        self.alldhpks = {} # received DH public keys 

    @staticmethod
    def set_scenario(dimension, valuesize, keysize, threshold, nclients):
        &#34;&#34;&#34;Sets up the parameters of the protocol.&#34;&#34;&#34;
        Client.dimension = dimension
        Client.valuesize = valuesize
        Client.nclients = nclients
        Client.expandedvaluesize = valuesize + ceil(log2(nclients))
        Client.keysize = keysize
        Client.threshold = threshold
        Client.Uall = [i+1 for i in range(nclients)]
        Client.prg = PRG(dimension, valuesize)
        Client.SSb = SSS(PRG.security)
        Client.SSsk = SSS(keysize)

    def new_fl_step(self):
        &#34;&#34;&#34;Starts a new FL round. 
        
        It increments the round counter and regenrates a new random input (This should be replaced with the actual training of the model).&#34;&#34;&#34;   
        self.step += 1
        self.U1 = []
        self.U2 = []
        self.U4 = []
        self.bshares = {}
        self.keyshares = {}
        self.bshares = {}
        self.KAs= KAS() 
        self.KAc= KAS() 
        self.ckeys = {}
        self.b = 0
        self.alldhpks = {}
        self.key = [0]*Client.dimension
        # generate a new input vector
        self.X = [random.SystemRandom().getrandbits(Client.valuesize) for _ in range(Client.dimension)]
                
    def advertise_keys(self):
        &#34;&#34;&#34;Round 0 - AdvertiseKeys: User advertise the his generated keys. 
        
        **Returns**: 
        ----------------
        A user identifier, and two public keys (type: (`int`, `PublicKey`, `PublicKey`)).
        &#34;&#34;&#34;

        # generate DH key pairs for masking key
        self.KAs.generate()
                
        # generate DH key pairs for channel key
        self.KAc.generate()

        self.U1.append(self.user)

        # send user id and public keys
        return self.user, self.KAs.pk, self.KAc.pk

    def share_keys(self, alldhpks, alldhpkc):
        &#34;&#34;&#34;Round 1 - ShareKeys: User setups and share its keys with other users. 
        
        It accepts the public keys of other users and computes the shared keys and the JL key. It also shares the JL key using **TJL.SKShare** and returns its shares.
        
        ** Args **:
        -----------
        *alldhpkc* : `dict` -- 
            The public key of each user (used to construct secret channels).

        *alldhpks* : `dict` -- 
            The public key of each user (used to compute the user mask).

        **Returns**: 
        ----------------
        The user identifier and a dictionary of encrypted share pairs of the blinding mask and DH secret key  (type: (`int`, `dict`)).
        &#34;&#34;&#34;
        assert alldhpkc.keys() == alldhpks.keys()
        assert len(alldhpkc.keys()) &gt;= self.threshold
        assert _setlen(alldhpkc.values()) == len(alldhpkc.values())  
        assert _setlen(alldhpks.values()) == len(alldhpks.values())  

        self.U1 += list(alldhpks.keys())

        # for each user compute agreed key
        for vuser in alldhpkc:
            if vuser == self.user:
                continue
            # compute channel key
            self.ckeys[vuser] = self.KAc.agree(alldhpkc[vuser])


        # sample a random element b
        self.b = random.SystemRandom().getrandbits(128)

        # generate t-out-of-U shares of b
        bshares = Client.SSb.share(self.threshold, self.nclients, self.b)


        # generate t-out-of-n shares of DH key
        kshares = Client.SSsk.share(self.threshold, self.nclients, self.KAs.get_sk_bytes())

        # encrypt the shares for each user
        E = {}
        for kshare, bshare in zip(kshares, bshares):
            assert kshare.idx == bshare.idx
            vuser = kshare.idx
            if self.user == vuser:
                self.keyshares[self.user] = kshare
                self.bshares[self.user] = bshare
                continue
            key = AESKEY(self.ckeys[vuser])
            sharelen = len(gmpy2.to_binary(kshare.value._value))
            message = self.user.to_bytes(2,&#34;big&#34;) + vuser.to_bytes(2,&#34;big&#34;) + sharelen.to_bytes(2,&#34;big&#34;) + gmpy2.to_binary(kshare.value._value) + gmpy2.to_binary(bshare.value._value)
            e = key.encrypt(message)
            E[vuser] = e

        self.alldhpks = alldhpks
     
        # send the user id and the encrypted shares
        return self.user, E

    def masked_input_collection(self, eshares):
        &#34;&#34;&#34;Round 2 - MaskedInputCollection: User protect its input and sends it to the server. 
        
        ## **Args**:
        -------------
        *eshares* : `dict` -- 
            The encrypted shares of the blinding mask and the Dh key of the users

        **Returns**: 
        ----------------
        The user identifier, and the protected input (type: (`int`, `list`).&#34;&#34;&#34;
        assert len(eshares) + 1 &gt;= self.threshold

        self.U2 = [self.user] + list(eshares.keys())
        self.eshares = eshares

        # for each user compute masking agreed key
        for vuser in self.alldhpks:
            if vuser == self.user:
                continue
            # compute masking key
            sv = self.KAs.agree(self.alldhpks[vuser])
            if vuser &gt; self.user:
                self.key = subs_vectors(self.key, Client.prg.eval(sv), 2**Client.expandedvaluesize)
            else:
                self.key = add_vectors(self.key, Client.prg.eval(sv), 2**Client.expandedvaluesize)
        
        # extend b using PRG
        B = Client.prg.eval(self.b)

        # compute the masked input
        mask = add_vectors(self.key, B, 2**Client.expandedvaluesize)
        Y = add_vectors(self.X, mask, 2**Client.expandedvaluesize)

        return self.user, Y

    def unmasking(self, U4):
        &#34;&#34;&#34;Round 4 - UnMasking: User send the shares of the users to the server.

        ** Args **:
        -----------
        *U4* : `list` -- 
            The list of still alive users

        **Returns**: 
        ----------------
        The user identifier, the shares of the DH secret key for dead users, and the shares of the blinding mask seed of alive users (type: (`int`, `dict`, `dict`)).
        &#34;&#34;&#34;
        assert len(U4) &gt;= self.threshold
        assert set(U4).issubset(set(self.U2))

        self.U4 = U4

        # decrypt the shares
        for vuser in self.eshares: 
            key = AESKEY(self.ckeys[vuser])
            message = key.decrypt(self.eshares[vuser])
            u = int.from_bytes(message[:2],&#34;big&#34;)
            v = int.from_bytes(message[2:4],&#34;big&#34;)
            sharelen = int.from_bytes(message[4:6],&#34;big&#34;)
            assert v == self.user and u == vuser, &#34;invalid encrypted message&#34;
            kshare = gmpy2.from_binary(message[6:sharelen+6])
            bshare = gmpy2.from_binary(message[sharelen+6:])
            self.bshares[vuser] = Share(self.user, Client.SSb.Field(bshare))
            self.keyshares[vuser] = Share(self.user, Client.SSsk.Field(kshare))


        # send either the b share of the key share of each user
        bshares = {}
        kshares = {}
        for vuser in self.U2:
            if vuser in self.U4:
                bshares[vuser] = self.bshares[vuser]
            else:
                kshares[vuser] = self.keyshares[vuser]


        # send the secret shares of b and key
        return self.user, kshares, bshares</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="ftsa.protocols.ccsftsa17.client.Client.dimension"><code class="name">var <span class="ident">dimension</span></code></dt>
<dd>
<div class="desc"><p>nb. of elements of the input vector (default: 1000)</p></div>
</dd>
<dt id="ftsa.protocols.ccsftsa17.client.Client.valuesize"><code class="name">var <span class="ident">valuesize</span></code></dt>
<dd>
<div class="desc"><p>bit length of each element in the input vector (default: 16)</p></div>
</dd>
<dt id="ftsa.protocols.ccsftsa17.client.Client.nclients"><code class="name">var <span class="ident">nclients</span></code></dt>
<dd>
<div class="desc"><p>number of FL clients (default: 10)</p></div>
</dd>
<dt id="ftsa.protocols.ccsftsa17.client.Client.expandedvaluesize"><code class="name">var <span class="ident">expandedvaluesize</span></code></dt>
<dd>
<div class="desc"><p>The expanded bit length to hold the sum of inputs</p></div>
</dd>
<dt id="ftsa.protocols.ccsftsa17.client.Client.keysize"><code class="name">var <span class="ident">keysize</span></code></dt>
<dd>
<div class="desc"><p>size of a DH key (default: 256)</p></div>
</dd>
<dt id="ftsa.protocols.ccsftsa17.client.Client.threshold"><code class="name">var <span class="ident">threshold</span></code></dt>
<dd>
<div class="desc"><p>threshold for secret sharing scheme (default: 2/3 of the nb. of clients)</p></div>
</dd>
<dt id="ftsa.protocols.ccsftsa17.client.Client.Uall"><code class="name">var <span class="ident">Uall</span></code></dt>
<dd>
<div class="desc"><p>set of all user identifiers</p></div>
</dd>
<dt id="ftsa.protocols.ccsftsa17.client.Client.prg"><code class="name">var <span class="ident">prg</span></code></dt>
<dd>
<div class="desc"><p>the pseudo-random generator</p></div>
</dd>
<dt id="ftsa.protocols.ccsftsa17.client.Client.SSb"><code class="name">var <span class="ident">SSb</span></code></dt>
<dd>
<div class="desc"><p>the secret sharing scheme for sharing the blinding mask</p></div>
</dd>
<dt id="ftsa.protocols.ccsftsa17.client.Client.SSsk"><code class="name">var <span class="ident">SSsk</span></code></dt>
<dd>
<div class="desc"><p>the secret sharing scheme for sharing the user mask</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="ftsa.protocols.ccsftsa17.client.Client.set_scenario"><code class="name flex">
<span>def <span class="ident">set_scenario</span></span>(<span>dimension, valuesize, keysize, threshold, nclients)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets up the parameters of the protocol.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def set_scenario(dimension, valuesize, keysize, threshold, nclients):
    &#34;&#34;&#34;Sets up the parameters of the protocol.&#34;&#34;&#34;
    Client.dimension = dimension
    Client.valuesize = valuesize
    Client.nclients = nclients
    Client.expandedvaluesize = valuesize + ceil(log2(nclients))
    Client.keysize = keysize
    Client.threshold = threshold
    Client.Uall = [i+1 for i in range(nclients)]
    Client.prg = PRG(dimension, valuesize)
    Client.SSb = SSS(PRG.security)
    Client.SSsk = SSS(keysize)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ftsa.protocols.ccsftsa17.client.Client.new_fl_step"><code class="name flex">
<span>def <span class="ident">new_fl_step</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Starts a new FL round. </p>
<p>It increments the round counter and regenrates a new random input (This should be replaced with the actual training of the model).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_fl_step(self):
    &#34;&#34;&#34;Starts a new FL round. 
    
    It increments the round counter and regenrates a new random input (This should be replaced with the actual training of the model).&#34;&#34;&#34;   
    self.step += 1
    self.U1 = []
    self.U2 = []
    self.U4 = []
    self.bshares = {}
    self.keyshares = {}
    self.bshares = {}
    self.KAs= KAS() 
    self.KAc= KAS() 
    self.ckeys = {}
    self.b = 0
    self.alldhpks = {}
    self.key = [0]*Client.dimension
    # generate a new input vector
    self.X = [random.SystemRandom().getrandbits(Client.valuesize) for _ in range(Client.dimension)]</code></pre>
</details>
</dd>
<dt id="ftsa.protocols.ccsftsa17.client.Client.advertise_keys"><code class="name flex">
<span>def <span class="ident">advertise_keys</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Round 0 - AdvertiseKeys: User advertise the his generated keys. </p>
<h2 id="returns"><strong>Returns</strong>:</h2>
<p>A user identifier, and two public keys (type: (<code>int</code>, <code>PublicKey</code>, <code>PublicKey</code>)).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def advertise_keys(self):
    &#34;&#34;&#34;Round 0 - AdvertiseKeys: User advertise the his generated keys. 
    
    **Returns**: 
    ----------------
    A user identifier, and two public keys (type: (`int`, `PublicKey`, `PublicKey`)).
    &#34;&#34;&#34;

    # generate DH key pairs for masking key
    self.KAs.generate()
            
    # generate DH key pairs for channel key
    self.KAc.generate()

    self.U1.append(self.user)

    # send user id and public keys
    return self.user, self.KAs.pk, self.KAc.pk</code></pre>
</details>
</dd>
<dt id="ftsa.protocols.ccsftsa17.client.Client.share_keys"><code class="name flex">
<span>def <span class="ident">share_keys</span></span>(<span>self, alldhpks, alldhpkc)</span>
</code></dt>
<dd>
<div class="desc"><p>Round 1 - ShareKeys: User setups and share its keys with other users. </p>
<p>It accepts the public keys of other users and computes the shared keys and the JL key. It also shares the JL key using <strong>TJL.SKShare</strong> and returns its shares.</p>
<h2 id="args"><strong> Args </strong>:</h2>
<p><em>alldhpkc</em> : <code>dict</code> &ndash;
The public key of each user (used to construct secret channels).</p>
<p><em>alldhpks</em> : <code>dict</code> &ndash;
The public key of each user (used to compute the user mask).</p>
<h2 id="returns"><strong>Returns</strong>:</h2>
<p>The user identifier and a dictionary of encrypted share pairs of the blinding mask and DH secret key
(type: (<code>int</code>, <code>dict</code>)).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def share_keys(self, alldhpks, alldhpkc):
    &#34;&#34;&#34;Round 1 - ShareKeys: User setups and share its keys with other users. 
    
    It accepts the public keys of other users and computes the shared keys and the JL key. It also shares the JL key using **TJL.SKShare** and returns its shares.
    
    ** Args **:
    -----------
    *alldhpkc* : `dict` -- 
        The public key of each user (used to construct secret channels).

    *alldhpks* : `dict` -- 
        The public key of each user (used to compute the user mask).

    **Returns**: 
    ----------------
    The user identifier and a dictionary of encrypted share pairs of the blinding mask and DH secret key  (type: (`int`, `dict`)).
    &#34;&#34;&#34;
    assert alldhpkc.keys() == alldhpks.keys()
    assert len(alldhpkc.keys()) &gt;= self.threshold
    assert _setlen(alldhpkc.values()) == len(alldhpkc.values())  
    assert _setlen(alldhpks.values()) == len(alldhpks.values())  

    self.U1 += list(alldhpks.keys())

    # for each user compute agreed key
    for vuser in alldhpkc:
        if vuser == self.user:
            continue
        # compute channel key
        self.ckeys[vuser] = self.KAc.agree(alldhpkc[vuser])


    # sample a random element b
    self.b = random.SystemRandom().getrandbits(128)

    # generate t-out-of-U shares of b
    bshares = Client.SSb.share(self.threshold, self.nclients, self.b)


    # generate t-out-of-n shares of DH key
    kshares = Client.SSsk.share(self.threshold, self.nclients, self.KAs.get_sk_bytes())

    # encrypt the shares for each user
    E = {}
    for kshare, bshare in zip(kshares, bshares):
        assert kshare.idx == bshare.idx
        vuser = kshare.idx
        if self.user == vuser:
            self.keyshares[self.user] = kshare
            self.bshares[self.user] = bshare
            continue
        key = AESKEY(self.ckeys[vuser])
        sharelen = len(gmpy2.to_binary(kshare.value._value))
        message = self.user.to_bytes(2,&#34;big&#34;) + vuser.to_bytes(2,&#34;big&#34;) + sharelen.to_bytes(2,&#34;big&#34;) + gmpy2.to_binary(kshare.value._value) + gmpy2.to_binary(bshare.value._value)
        e = key.encrypt(message)
        E[vuser] = e

    self.alldhpks = alldhpks
 
    # send the user id and the encrypted shares
    return self.user, E</code></pre>
</details>
</dd>
<dt id="ftsa.protocols.ccsftsa17.client.Client.masked_input_collection"><code class="name flex">
<span>def <span class="ident">masked_input_collection</span></span>(<span>self, eshares)</span>
</code></dt>
<dd>
<div class="desc"><p>Round 2 - MaskedInputCollection: User protect its input and sends it to the server. </p>
<h2 id="args"><strong>Args</strong>:</h2>
<hr>
<p><em>eshares</em> : <code>dict</code> &ndash;
The encrypted shares of the blinding mask and the Dh key of the users</p>
<h2 id="returns"><strong>Returns</strong>:</h2>
<p>The user identifier, and the protected input (type: (<code>int</code>, <code>list</code>).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def masked_input_collection(self, eshares):
    &#34;&#34;&#34;Round 2 - MaskedInputCollection: User protect its input and sends it to the server. 
    
    ## **Args**:
    -------------
    *eshares* : `dict` -- 
        The encrypted shares of the blinding mask and the Dh key of the users

    **Returns**: 
    ----------------
    The user identifier, and the protected input (type: (`int`, `list`).&#34;&#34;&#34;
    assert len(eshares) + 1 &gt;= self.threshold

    self.U2 = [self.user] + list(eshares.keys())
    self.eshares = eshares

    # for each user compute masking agreed key
    for vuser in self.alldhpks:
        if vuser == self.user:
            continue
        # compute masking key
        sv = self.KAs.agree(self.alldhpks[vuser])
        if vuser &gt; self.user:
            self.key = subs_vectors(self.key, Client.prg.eval(sv), 2**Client.expandedvaluesize)
        else:
            self.key = add_vectors(self.key, Client.prg.eval(sv), 2**Client.expandedvaluesize)
    
    # extend b using PRG
    B = Client.prg.eval(self.b)

    # compute the masked input
    mask = add_vectors(self.key, B, 2**Client.expandedvaluesize)
    Y = add_vectors(self.X, mask, 2**Client.expandedvaluesize)

    return self.user, Y</code></pre>
</details>
</dd>
<dt id="ftsa.protocols.ccsftsa17.client.Client.unmasking"><code class="name flex">
<span>def <span class="ident">unmasking</span></span>(<span>self, U4)</span>
</code></dt>
<dd>
<div class="desc"><p>Round 4 - UnMasking: User send the shares of the users to the server.</p>
<h2 id="args"><strong> Args </strong>:</h2>
<p><em>U4</em> : <code>list</code> &ndash;
The list of still alive users</p>
<h2 id="returns"><strong>Returns</strong>:</h2>
<p>The user identifier, the shares of the DH secret key for dead users, and the shares of the blinding mask seed of alive users (type: (<code>int</code>, <code>dict</code>, <code>dict</code>)).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unmasking(self, U4):
    &#34;&#34;&#34;Round 4 - UnMasking: User send the shares of the users to the server.

    ** Args **:
    -----------
    *U4* : `list` -- 
        The list of still alive users

    **Returns**: 
    ----------------
    The user identifier, the shares of the DH secret key for dead users, and the shares of the blinding mask seed of alive users (type: (`int`, `dict`, `dict`)).
    &#34;&#34;&#34;
    assert len(U4) &gt;= self.threshold
    assert set(U4).issubset(set(self.U2))

    self.U4 = U4

    # decrypt the shares
    for vuser in self.eshares: 
        key = AESKEY(self.ckeys[vuser])
        message = key.decrypt(self.eshares[vuser])
        u = int.from_bytes(message[:2],&#34;big&#34;)
        v = int.from_bytes(message[2:4],&#34;big&#34;)
        sharelen = int.from_bytes(message[4:6],&#34;big&#34;)
        assert v == self.user and u == vuser, &#34;invalid encrypted message&#34;
        kshare = gmpy2.from_binary(message[6:sharelen+6])
        bshare = gmpy2.from_binary(message[sharelen+6:])
        self.bshares[vuser] = Share(self.user, Client.SSb.Field(bshare))
        self.keyshares[vuser] = Share(self.user, Client.SSsk.Field(kshare))


    # send either the b share of the key share of each user
    bshares = {}
    kshares = {}
    for vuser in self.U2:
        if vuser in self.U4:
            bshares[vuser] = self.bshares[vuser]
        else:
            kshares[vuser] = self.keyshares[vuser]


    # send the secret shares of b and key
    return self.user, kshares, bshares</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ftsa.protocols.ccsftsa17" href="index.html">ftsa.protocols.ccsftsa17</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ftsa.protocols.ccsftsa17.client.Client" href="#ftsa.protocols.ccsftsa17.client.Client">Client</a></code></h4>
<ul class="">
<li><code><a title="ftsa.protocols.ccsftsa17.client.Client.set_scenario" href="#ftsa.protocols.ccsftsa17.client.Client.set_scenario">set_scenario</a></code></li>
<li><code><a title="ftsa.protocols.ccsftsa17.client.Client.new_fl_step" href="#ftsa.protocols.ccsftsa17.client.Client.new_fl_step">new_fl_step</a></code></li>
<li><code><a title="ftsa.protocols.ccsftsa17.client.Client.advertise_keys" href="#ftsa.protocols.ccsftsa17.client.Client.advertise_keys">advertise_keys</a></code></li>
<li><code><a title="ftsa.protocols.ccsftsa17.client.Client.share_keys" href="#ftsa.protocols.ccsftsa17.client.Client.share_keys">share_keys</a></code></li>
<li><code><a title="ftsa.protocols.ccsftsa17.client.Client.masked_input_collection" href="#ftsa.protocols.ccsftsa17.client.Client.masked_input_collection">masked_input_collection</a></code></li>
<li><code><a title="ftsa.protocols.ccsftsa17.client.Client.unmasking" href="#ftsa.protocols.ccsftsa17.client.Client.unmasking">unmasking</a></code></li>
<li><code><a title="ftsa.protocols.ccsftsa17.client.Client.dimension" href="#ftsa.protocols.ccsftsa17.client.Client.dimension">dimension</a></code></li>
<li><code><a title="ftsa.protocols.ccsftsa17.client.Client.valuesize" href="#ftsa.protocols.ccsftsa17.client.Client.valuesize">valuesize</a></code></li>
<li><code><a title="ftsa.protocols.ccsftsa17.client.Client.nclients" href="#ftsa.protocols.ccsftsa17.client.Client.nclients">nclients</a></code></li>
<li><code><a title="ftsa.protocols.ccsftsa17.client.Client.expandedvaluesize" href="#ftsa.protocols.ccsftsa17.client.Client.expandedvaluesize">expandedvaluesize</a></code></li>
<li><code><a title="ftsa.protocols.ccsftsa17.client.Client.keysize" href="#ftsa.protocols.ccsftsa17.client.Client.keysize">keysize</a></code></li>
<li><code><a title="ftsa.protocols.ccsftsa17.client.Client.threshold" href="#ftsa.protocols.ccsftsa17.client.Client.threshold">threshold</a></code></li>
<li><code><a title="ftsa.protocols.ccsftsa17.client.Client.Uall" href="#ftsa.protocols.ccsftsa17.client.Client.Uall">Uall</a></code></li>
<li><code><a title="ftsa.protocols.ccsftsa17.client.Client.prg" href="#ftsa.protocols.ccsftsa17.client.Client.prg">prg</a></code></li>
<li><code><a title="ftsa.protocols.ccsftsa17.client.Client.SSb" href="#ftsa.protocols.ccsftsa17.client.Client.SSb">SSb</a></code></li>
<li><code><a title="ftsa.protocols.ccsftsa17.client.Client.SSsk" href="#ftsa.protocols.ccsftsa17.client.Client.SSsk">SSsk</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>